
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/components/Aframe/systems/super-hands.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">src/components/Aframe/systems</a> super-hands.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/288</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/339</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/128</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/31</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >r(</span>e,n,t){function <span class="fstat-no" title="function not covered" >o(</span>i,f){<span class="cstat-no" title="statement not covered" >if(!n[i]){<span class="cstat-no" title="statement not covered" >if(!e[i]){var c=<span class="cstat-no" title="statement not covered" >"function"==typeof require&amp;&amp;require;<span class="cstat-no" title="statement not covered" ></span>if(!f&amp;&amp;c)<span class="cstat-no" title="statement not covered" >return c(i,!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(u)<span class="cstat-no" title="statement not covered" >return u(i,!0);v</span></span>ar a=<span class="cstat-no" title="statement not covered" >new Error("Cannot find module '"+i+"'");<span class="cstat-no" title="statement not covered" ></span>throw a.code="MODULE_NOT_FOUND",a}</span>v</span>ar p=<span class="cstat-no" title="statement not covered" >n[i]={exports:{}};<span class="cstat-no" title="statement not covered" ></span>e[i][0].call(p.exports,<span class="fstat-no" title="function not covered" >fu</span>nction(r){var n=<span class="cstat-no" title="statement not covered" >e[i][1][r];<span class="cstat-no" title="statement not covered" ></span>return o(n||r)}</span>,p,p.exports,r,e,n,t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n[i].exports}<span class="cstat-no" title="statement not covered" ></span>for(var u=<span class="cstat-no" title="statement not covered" >"function"==typeof require&amp;&amp;require,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >o(t[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}<span class="cstat-no" title="statement not covered" ></span>return r}</span>)()({1:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){</span>
"use strict";/* global AFRAME */<span class="cstat-no" title="statement not covered" >if("undefined"==typeof AFRAME)<span class="cstat-no" title="statement not covered" >throw new Error("Component attempted to register before AFRAME was available.");/</span></span>**
 * Super Hands component for A-Frame.
 */<span class="cstat-no" title="statement not covered" >require("./systems/super-hands-system.js"),require("./reaction_components/hoverable.js"),require("./reaction_components/grabbable.js"),require("./reaction_components/stretchable.js"),require("./reaction_components/drag-droppable.js"),require("./reaction_components/draggable.js"),require("./reaction_components/droppable.js"),require("./reaction_components/clickable.js"),AFRAME.registerComponent("super-hands",{schema:{colliderEvent:{default:"hit"},colliderEventProperty:{default:"el"},colliderEndEvent:{default:"hitend"},colliderEndEventProperty:{default:"el"},grabStartButtons:{default:["gripdown","trackpaddown","triggerdown","gripclose","abuttondown","bbuttondown","xbuttondown","ybuttondown","pointup","thumbup","pointingstart","pistolstart","thumbstickdown","mousedown","touchstart"]},grabEndButtons:{default:["gripup","trackpadup","triggerup","gripopen","abuttonup","bbuttonup","xbuttonup","ybuttonup","pointdown","thumbdown","pointingend","pistolend","thumbstickup","mouseup","touchend"]},stretchStartButtons:{default:["gripdown","trackpaddown","triggerdown","gripclose","abuttondown","bbuttondown","xbuttondown","ybuttondown","pointup","thumbup","pointingstart","pistolstart","thumbstickdown","mousedown","touchstart"]},stretchEndButtons:{default:["gripup","trackpadup","triggerup","gripopen","abuttonup","bbuttonup","xbuttonup","ybuttonup","pointdown","thumbdown","pointingend","pistolend","thumbstickup","mouseup","touchend"]},dragDropStartButtons:{default:["gripdown","trackpaddown","triggerdown","gripclose","abuttondown","bbuttondown","xbuttondown","ybuttondown","pointup","thumbup","pointingstart","pistolstart","thumbstickdown","mousedown","touchstart"]},dragDropEndButtons:{default:["gripup","trackpadup","triggerup","gripopen","abuttonup","bbuttonup","xbuttonup","ybuttonup","pointdown","thumbdown","pointingend","pistolend","thumbstickup","mouseup","touchend"]},interval:{default:0}},/**</span>
   * Set if component needs multiple instancing.
   */multiple:!1,/**
   * Called once when component is attached. Generally for initial setup.
   */init:<span class="fstat-no" title="function not covered" >fu</span>nction(){// constants
// links to other systems/components
// state tracking - global event handlers (GEH)
// state tracking - reaction components
<span class="cstat-no" title="statement not covered" >this.HOVER_EVENT="hover-start",this.UNHOVER_EVENT="hover-end",this.GRAB_EVENT="grab-start",this.UNGRAB_EVENT="grab-end",this.STRETCH_EVENT="stretch-start",this.UNSTRETCH_EVENT="stretch-end",this.DRAG_EVENT="drag-start",this.UNDRAG_EVENT="drag-end",this.DRAGOVER_EVENT="dragover-start",this.UNDRAGOVER_EVENT="dragover-end",this.DRAGDROP_EVENT="drag-drop",this.otherSuperHand=null,this.gehDragged=new Set,this.gehClicking=new Set,this.hoverEls=[],this.hoverElsIntersections=[],this.prevCheckTime=null,this.state=new Map,this.dragging=!1,this.unHover=this.unHover.bind(this),this.unWatch=this.unWatch.bind(this),this.onHit=this.onHit.bind(this),this.onGrabStartButton=this.onGrabStartButton.bind(this),this.onGrabEndButton=this.onGrabEndButton.bind(this),this.onStretchStartButton=this.onStretchStartButton.bind(this),this.onStretchEndButton=this.onStretchEndButton.bind(this),this.onDragDropStartButton=this.onDragDropStartButton.bind(this),this.onDragDropEndButton=this.onDragDropEndButton.bind(this),this.system.registerMe(this)}</span>,/**
   * Called when component is attached and when component data changes.
   * Generally modifies the entity based on the data.
   */update:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >this.unRegisterListeners(a),this.registerListeners()}</span>,/**
   * Called when a component is removed (e.g., via removeAttribute).
   * Generally undoes all modifications to the entity.
   */remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.system.unregisterMe(this),this.unRegisterListeners(),this.hoverEls.length=0,this.state.get(this.HOVER_EVENT)&amp;&amp;this._unHover(this.state.get(this.HOVER_EVENT)),this.onGrabEndButton(),this.onStretchEndButton(),this.onDragDropEndButton()}</span>,tick:<span class="fstat-no" title="function not covered" >fu</span>nction(){// closer objects and objects with no distance come later in list
function <span class="fstat-no" title="function not covered" >a(</span>c,a){const b=<span class="cstat-no" title="statement not covered" >null==c.distance?-1:c.distance,</span>d=<span class="cstat-no" title="statement not covered" >null==a.distance?-1:a.distance;<span class="cstat-no" title="statement not covered" ></span>return b&lt;d?1:d&lt;b?-1:0}<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(b){const c=<span class="cstat-no" title="statement not covered" >this.data,</span>d=<span class="cstat-no" title="statement not covered" >this.prevCheckTime;<span class="cstat-no" title="statement not covered" ></span>if(d&amp;&amp;b-d&lt;c.interval)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.prevCheckTime=b;l</span>et e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>this.hoverElsIntersections.sort(a);<span class="cstat-no" title="statement not covered" >f</span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;this.hoverElsIntersections.length;a++)<span class="cstat-no" title="statement not covered" >this.hoverEls[a]!==this.hoverElsIntersections[a].object.el&amp;&amp;(e=!0,this.hoverEls[a]=this.hoverElsIntersections[a].object.el);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;this.hover()}</span>}</span>(),onGrabStartButton:<span class="fstat-no" title="function not covered" >fu</span>nction(a){let b=<span class="cstat-no" title="statement not covered" >this.state.get(this.GRAB_EVENT);<span class="cstat-no" title="statement not covered" ></span>this.dispatchMouseEventAll("mousedown",this.el),this.gehClicking=new Set(this.hoverEls),b||(b=this.findTarget(this.GRAB_EVENT,{hand:this.el,buttonEvent:a}),b&amp;&amp;(this.state.set(this.GRAB_EVENT,b),this._unHover(b)))}</span>,onGrabEndButton:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.hoverEls.filter(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >this.gehClicking.has(a))</span>,</span>c=<span class="cstat-no" title="statement not covered" >this.state.get(this.GRAB_EVENT),</span>d=<span class="cstat-no" title="statement not covered" >{hand:this.el,buttonEvent:a};<span class="cstat-no" title="statement not covered" ></span>this.dispatchMouseEventAll("mouseup",this.el);<span class="cstat-no" title="statement not covered" >f</span>or(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;b.length;c++)<span class="cstat-no" title="statement not covered" >this.dispatchMouseEvent(b[c],"click",this.el);<span class="cstat-no" title="statement not covered" >t</span></span>his.gehClicking.clear(),c&amp;&amp;!this.emitCancelable(c,this.UNGRAB_EVENT,d)&amp;&amp;(this.promoteHoveredEl(this.state.get(this.GRAB_EVENT)),this.state.delete(this.GRAB_EVENT),this.hover())}</span>,onStretchStartButton:<span class="fstat-no" title="function not covered" >fu</span>nction(a){let b=<span class="cstat-no" title="statement not covered" >this.state.get(this.STRETCH_EVENT);<span class="cstat-no" title="statement not covered" ></span>b||(b=this.findTarget(this.STRETCH_EVENT,{hand:this.el,buttonEvent:a}),b&amp;&amp;(this.state.set(this.STRETCH_EVENT,b),this._unHover(b)))}</span>,onStretchEndButton:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.state.get(this.STRETCH_EVENT),</span>c=<span class="cstat-no" title="statement not covered" >{hand:this.el,buttonEvent:a};<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;!this.emitCancelable(b,this.UNSTRETCH_EVENT,c)&amp;&amp;(this.promoteHoveredEl(b),this.state.delete(this.STRETCH_EVENT),this.hover())}</span>,onDragDropStartButton:<span class="fstat-no" title="function not covered" >fu</span>nction(a){let b=<span class="cstat-no" title="statement not covered" >this.state.get(this.DRAG_EVENT);<span class="cstat-no" title="statement not covered" ></span>this.dragging=!0,this.hoverEls.length&amp;&amp;(this.gehDragged=new Set(this.hoverEls),this.dispatchMouseEventAll("dragstart",this.el)),b||(b=this.state.get(this.GRAB_EVENT)&amp;&amp;!this.emitCancelable(this.state.get(this.GRAB_EVENT),this.DRAG_EVENT,{hand:this.el,buttonEvent:a})?this.state.get(this.GRAB_EVENT):this.findTarget(this.DRAG_EVENT,{hand:this.el,buttonEvent:a}),b&amp;&amp;(this.state.set(this.DRAG_EVENT,b),this._unHover(b)))}</span>,onDragDropEndButton:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.state.get(this.DRAG_EVENT);<span class="cstat-no" title="statement not covered" ></span>if(this.dragging=!1,this.gehDragged.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.dispatchMouseEvent(a,"dragend",this.el),this.dispatchMouseEventAll("drop",a,!0,!0),this.dispatchMouseEventAll("dragleave",a,!0,!0)}</span>),this.gehDragged.clear(),b){const c=<span class="cstat-no" title="statement not covered" >{hand:this.el,dropped:b,on:null,buttonEvent:a},</span>d=<span class="cstat-no" title="statement not covered" >{hand:this.el,buttonEvent:a},</span>e=<span class="cstat-no" title="statement not covered" >this.findTarget(this.DRAGDROP_EVENT,c,!0);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(c.on=e,this.emitCancelable(b,this.DRAGDROP_EVENT,c),this._unHover(e)),this.emitCancelable(b,this.UNDRAG_EVENT,d)||(this.promoteHoveredEl(b),this.state.delete(this.DRAG_EVENT),this.hover())}</span>}</span>,processHitEl:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){const c=<span class="cstat-no" title="statement not covered" >b&amp;&amp;b.distance,</span>d=<span class="cstat-no" title="statement not covered" >this.hoverElsIntersections,</span>e=<span class="cstat-no" title="statement not covered" >this.hoverEls,</span>f=<span class="cstat-no" title="statement not covered" >this.hoverEls.indexOf(a);</span>let g=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(-1===f){// insert in order of distance when available</span>
<span class="cstat-no" title="statement not covered" >if(g=!0,null!=c){let f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;f&lt;d.length&amp;&amp;c&lt;d[f].distance;)<span class="cstat-no" title="statement not covered" >f++;<span class="cstat-no" title="statement not covered" >e</span></span>.splice(f,0,a),d.splice(f,0,b)}</span>else <span class="cstat-no" title="statement not covered" >e.push(a),d.push({object:{el:a}});<span class="cstat-no" title="statement not covered" >t</span></span>his.dispatchMouseEvent(a,"mouseover",this.el),this.dragging&amp;&amp;this.gehDragged.size&amp;&amp;this.gehDragged.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.dispatchMouseEventAll("dragenter",a,!0,!0)}</span>)}<span class="cstat-no" title="statement not covered" ></span>return g}</span>,onHit:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >a.detail[this.data.colliderEventProperty];</span>let c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(b){<span class="cstat-no" title="statement not covered" >if(Array.isArray(b))<span class="cstat-no" title="statement not covered" >for(let d,e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;b.length;e++)<span class="cstat-no" title="statement not covered" >d=a.detail.intersections&amp;&amp;a.detail.intersections[e],c+=this.processHitEl(b[e],d);e</span></span>lse <span class="cstat-no" title="statement not covered" >c+=this.processHitEl(b,null);<span class="cstat-no" title="statement not covered" >c</span></span>&amp;&amp;this.hover()}</span>}</span>,/* search collided entities for target to hover/dragover */hover:<span class="fstat-no" title="function not covered" >fu</span>nction(){let a,b;// end previous hover
<span class="cstat-no" title="statement not covered" >this.state.has(this.HOVER_EVENT)&amp;&amp;this._unHover(this.state.get(this.HOVER_EVENT),!0),this.state.has(this.DRAGOVER_EVENT)&amp;&amp;this._unHover(this.state.get(this.DRAGOVER_EVENT),!0),this.dragging&amp;&amp;this.state.get(this.DRAG_EVENT)&amp;&amp;(a={hand:this.el,hovered:b,carried:this.state.get(this.DRAG_EVENT)},b=this.findTarget(this.DRAGOVER_EVENT,a,!0),b&amp;&amp;(this.emitCancelable(this.state.get(this.DRAG_EVENT),this.DRAGOVER_EVENT,a),this.state.set(this.DRAGOVER_EVENT,b))),this.state.has(this.DRAGOVER_EVENT)||(b=this.findTarget(this.HOVER_EVENT,{hand:this.el},!0),b&amp;&amp;this.state.set(this.HOVER_EVENT,b))}</span>,/* called when controller moves out of collision range of entity */unHover:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >a.detail[this.data.colliderEndEventProperty];<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;(Array.isArray(b)?b.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >this._unHover(a))</span>:this._unHover(b))}</span>,/* inner unHover steps needed regardless of cause of unHover */_unHover:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){let c,d=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>a===this.state.get(this.DRAGOVER_EVENT)&amp;&amp;(this.state.delete(this.DRAGOVER_EVENT),d=!0,c={hand:this.el,hovered:a,carried:this.state.get(this.DRAG_EVENT)},this.emitCancelable(a,this.UNDRAGOVER_EVENT,c),this.state.has(this.DRAG_EVENT)&amp;&amp;this.emitCancelable(this.state.get(this.DRAG_EVENT),this.UNDRAGOVER_EVENT,c)),a===this.state.get(this.HOVER_EVENT)&amp;&amp;(this.state.delete(this.HOVER_EVENT),d=!0,this.emitCancelable(a,this.UNHOVER_EVENT,{hand:this.el})),d&amp;&amp;!b&amp;&amp;this.hover()}</span>,unWatch:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >a.detail[this.data.colliderEndEventProperty];<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;(Array.isArray(b)?b.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >this._unWatch(a))</span>:this._unWatch(b))}</span>,_unWatch:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.hoverEls.indexOf(a);<span class="cstat-no" title="statement not covered" ></span>-1!==b&amp;&amp;(this.hoverEls.splice(b,1),this.hoverElsIntersections.splice(b,1)),this.gehDragged.forEach(<span class="fstat-no" title="function not covered" >b=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.dispatchMouseEvent(a,"dragleave",b),this.dispatchMouseEvent(b,"dragleave",a)}</span>),this.dispatchMouseEvent(a,"mouseout",this.el)}</span>,registerListeners:<span class="fstat-no" title="function not covered" >fu</span>nction(){// binding order to keep grabEnd from triggering dragover
// again before dragDropEnd can delete its carried state
<span class="cstat-no" title="statement not covered" >this.el.addEventListener(this.data.colliderEvent,this.onHit),this.el.addEventListener(this.data.colliderEndEvent,this.unWatch),this.el.addEventListener(this.data.colliderEndEvent,this.unHover),this.data.grabStartButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.addEventListener(a,this.onGrabStartButton)}</span>),this.data.stretchStartButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.addEventListener(a,this.onStretchStartButton)}</span>),this.data.dragDropStartButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.addEventListener(a,this.onDragDropStartButton)}</span>),this.data.dragDropEndButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.addEventListener(a,this.onDragDropEndButton)}</span>),this.data.stretchEndButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.addEventListener(a,this.onStretchEndButton)}</span>),this.data.grabEndButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.addEventListener(a,this.onGrabEndButton)}</span>)}</span>,unRegisterListeners:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a=a||this.data;<span class="cstat-no" title="statement not covered" >0</span>===Object.keys(a).length||(this.el.removeEventListener(a.colliderEvent,this.onHit),this.el.removeEventListener(a.colliderEndEvent,this.unHover),this.el.removeEventListener(a.colliderEndEvent,this.unWatch),a.grabStartButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(a,this.onGrabStartButton)}</span>),a.grabEndButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(a,this.onGrabEndButton)}</span>),a.stretchStartButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(a,this.onStretchStartButton)}</span>),a.stretchEndButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(a,this.onStretchEndButton)}</span>),a.dragDropStartButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(a,this.onDragDropStartButton)}</span>),a.dragDropEndButtons.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(a,this.onDragDropEndButton)}</span>))}</span>,emitCancelable:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b,c){<span class="cstat-no" title="statement not covered" >c=c||{};c</span>onst d=<span class="cstat-no" title="statement not covered" >{bubbles:!0,cancelable:!0,detail:c};<span class="cstat-no" title="statement not covered" ></span>d.detail.target=d.detail.target||a;c</span>onst e=<span class="cstat-no" title="statement not covered" >new window.CustomEvent(b,d);<span class="cstat-no" title="statement not covered" ></span>return a.dispatchEvent(e)}</span>,dispatchMouseEvent:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b,c){const d=<span class="cstat-no" title="statement not covered" >new window.MouseEvent(b,{relatedTarget:c});<span class="cstat-no" title="statement not covered" ></span>a.dispatchEvent(d)}</span>,dispatchMouseEventAll:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b,c,d){let e=<span class="cstat-no" title="statement not covered" >this.hoverEls;<span class="cstat-no" title="statement not covered" ></span>if(c&amp;&amp;(e=e.filter(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a!==this.state.get(this.GRAB_EVENT)&amp;&amp;a!==this.state.get(this.DRAG_EVENT)&amp;&amp;a!==this.state.get(this.STRETCH_EVENT)&amp;&amp;!this.gehDragged.has(a))</span>),d)<span class="cstat-no" title="statement not covered" >for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;e.length;c++)<span class="cstat-no" title="statement not covered" >this.dispatchMouseEvent(e[c],a,b),this.dispatchMouseEvent(b,a,e[c]);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;e.length;c++)<span class="cstat-no" title="statement not covered" >this.dispatchMouseEvent(e[c],a,b)}</span></span></span>,findTarget:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b,c){let d,e=<span class="cstat-no" title="statement not covered" >this.hoverEls;<span class="cstat-no" title="statement not covered" ></span>for(c&amp;&amp;(e=e.filter(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a!==this.state.get(this.GRAB_EVENT)&amp;&amp;a!==this.state.get(this.DRAG_EVENT)&amp;&amp;a!==this.state.get(this.STRETCH_EVENT))</span>),d=e.length-1;0&lt;=d;d--)<span class="cstat-no" title="statement not covered" >if(!this.emitCancelable(e[d],a,b))<span class="cstat-no" title="statement not covered" >return e[d];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn null}</span>,// Helper to ensure dropping and regrabbing finds the same target for
// for order-sorted hoverEls (grabbing; no-op for distance-sorted (pointing)
promoteHoveredEl:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.hoverEls.indexOf(a);<span class="cstat-no" title="statement not covered" ></span>if(-1!==b&amp;&amp;null==this.hoverElsIntersections[b].distance){<span class="cstat-no" title="statement not covered" >this.hoverEls.splice(b,1);c</span>onst c=<span class="cstat-no" title="statement not covered" >this.hoverElsIntersections.splice(b,1);<span class="cstat-no" title="statement not covered" ></span>this.hoverEls.push(a),this.hoverElsIntersections.push(c[0])}</span>}</span>});
&nbsp;
},{"./reaction_components/clickable.js":2,"./reaction_components/drag-droppable.js":3,"./reaction_components/draggable.js":4,"./reaction_components/droppable.js":5,"./reaction_components/grabbable.js":6,"./reaction_components/hoverable.js":7,"./reaction_components/stretchable.js":10,"./systems/super-hands-system.js":11}],2:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME */const buttonCore=<span class="cstat-no" title="statement not covered" >require("./prototypes/buttons-proto.js");<span class="cstat-no" title="statement not covered" ></span>AFRAME.registerComponent("clickable",AFRAME.utils.extendDeep({},buttonCore,{schema:{onclick:{type:"string"}},init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.CLICKED_STATE="clicked",this.CLICK_EVENT="grab-start",this.UNCLICK_EVENT="grab-end",this.clickers=[],this.start=this.start.bind(this),this.end=this.end.bind(this),this.el.addEventListener(this.CLICK_EVENT,this.start),this.el.addEventListener(this.UNCLICK_EVENT,this.end)}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.CLICK_EVENT,this.start),this.el.removeEventListener(this.UNCLICK_EVENT,this.end)}</span>,start:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a.defaultPrevented||!this.startButtonOk(a)||(this.el.addState(this.CLICKED_STATE),-1===this.clickers.indexOf(a.detail.hand)&amp;&amp;(this.clickers.push(a.detail.hand),a.preventDefault&amp;&amp;a.preventDefault()))}</span>,end:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.clickers.indexOf(a.detail.hand);<span class="cstat-no" title="statement not covered" ></span>a.defaultPrevented||!this.endButtonOk(a)||(-1!==b&amp;&amp;this.clickers.splice(b,1),1&gt;this.clickers.length&amp;&amp;this.el.removeState(this.CLICKED_STATE),a.preventDefault&amp;&amp;a.preventDefault())}</span>}));</span>
&nbsp;
},{"./prototypes/buttons-proto.js":8}],3:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME */const inherit=<span class="cstat-no" title="statement not covered" >AFRAME.utils.extendDeep,</span>buttonCore=<span class="cstat-no" title="statement not covered" >require("./prototypes/buttons-proto.js");<span class="cstat-no" title="statement not covered" ></span>AFRAME.registerComponent("drag-droppable",inherit({},buttonCore,{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >console.warn("Warning: drag-droppable is deprecated. Use draggable and droppable components instead"),this.HOVERED_STATE="dragover",this.DRAGGED_STATE="dragged",this.HOVER_EVENT="dragover-start",this.UNHOVER_EVENT="dragover-end",this.DRAG_EVENT="drag-start",this.UNDRAG_EVENT="drag-end",this.DRAGDROP_EVENT="drag-drop",this.hoverStart=this.hoverStart.bind(this),this.dragStart=this.dragStart.bind(this),this.hoverEnd=this.hoverEnd.bind(this),this.dragEnd=this.dragEnd.bind(this),this.dragDrop=this.dragDrop.bind(this),this.el.addEventListener(this.HOVER_EVENT,this.hoverStart),this.el.addEventListener(this.DRAG_EVENT,this.dragStart),this.el.addEventListener(this.UNHOVER_EVENT,this.hoverEnd),this.el.addEventListener(this.UNDRAG_EVENT,this.dragEnd),this.el.addEventListener(this.DRAGDROP_EVENT,this.dragDrop)}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.HOVER_EVENT,this.hoverStart),this.el.removeEventListener(this.DRAG_EVENT,this.dragStart),this.el.removeEventListener(this.UNHOVER_EVENT,this.hoverEnd),this.el.removeEventListener(this.UNDRAG_EVENT,this.dragEnd),this.el.removeEventListener(this.DRAGDROP_EVENT,this.dragDrop)}</span>,hoverStart:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >this.el.addState(this.HOVERED_STATE),a.preventDefault&amp;&amp;a.preventDefault()}</span>,dragStart:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >this.startButtonOk(a)&amp;&amp;(this.el.addState(this.DRAGGED_STATE),a.preventDefault&amp;&amp;a.preventDefault())}</span>,hoverEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeState(this.HOVERED_STATE)}</span>,dragEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >this.endButtonOk(a)&amp;&amp;(this.el.removeState(this.DRAGGED_STATE),a.preventDefault&amp;&amp;a.preventDefault())}</span>,dragDrop:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >!this.endButtonOk(a)||a.preventDefault&amp;&amp;a.preventDefault()}</span>}));</span>
&nbsp;
},{"./prototypes/buttons-proto.js":8}],4:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME */const inherit=<span class="cstat-no" title="statement not covered" >AFRAME.utils.extendDeep,</span>buttonCore=<span class="cstat-no" title="statement not covered" >require("./prototypes/buttons-proto.js");<span class="cstat-no" title="statement not covered" ></span>AFRAME.registerComponent("draggable",inherit({},buttonCore,{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.DRAGGED_STATE="dragged",this.DRAG_EVENT="drag-start",this.UNDRAG_EVENT="drag-end",this.dragStartBound=this.dragStart.bind(this),this.dragEndBound=this.dragEnd.bind(this),this.el.addEventListener(this.DRAG_EVENT,this.dragStartBound),this.el.addEventListener(this.UNDRAG_EVENT,this.dragEndBound)}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.DRAG_EVENT,this.dragStart),this.el.removeEventListener(this.UNDRAG_EVENT,this.dragEnd)}</span>,dragStart:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a.defaultPrevented||!this.startButtonOk(a)||(this.el.addState(this.DRAGGED_STATE),a.preventDefault&amp;&amp;a.preventDefault())}</span>,dragEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a.defaultPrevented||!this.endButtonOk(a)||(this.el.removeState(this.DRAGGED_STATE),a.preventDefault&amp;&amp;a.preventDefault())}</span>}));</span>
&nbsp;
},{"./prototypes/buttons-proto.js":8}],5:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME */function <span class="fstat-no" title="function not covered" >elementMatches(</span>a,b){<span class="cstat-no" title="statement not covered" >return a.matches?a.matches(b):a.msMatchesSelector?a.msMatchesSelector(b):a.webkitMatchesSelector?a.webkitMatchesSelector(b):void 0}<span class="cstat-no" title="statement not covered" ></span>AFRAME.registerComponent("droppable",{schema:{accepts:{default:""},autoUpdate:{default:!0},acceptEvent:{default:""},rejectEvent:{default:""}},multiple:!0,init:<span class="fstat-no" title="function not covered" >fu</span>nction(){// better for Sinon spying if original method not overwritten</span>
<span class="cstat-no" title="statement not covered" >this.HOVERED_STATE="dragover",this.HOVER_EVENT="dragover-start",this.UNHOVER_EVENT="dragover-end",this.DRAGDROP_EVENT="drag-drop",this.hoverStartBound=this.hoverStart.bind(this),this.hoverEndBound=this.hoverEnd.bind(this),this.dragDropBound=this.dragDrop.bind(this),this.mutateAcceptsBound=this.mutateAccepts.bind(this),this.acceptableEntities=[],this.observer=new window.MutationObserver(this.mutateAcceptsBound),this.observerOpts={childList:!0,subtree:!0},this.el.addEventListener(this.HOVER_EVENT,this.hoverStartBound),this.el.addEventListener(this.UNHOVER_EVENT,this.hoverEndBound),this.el.addEventListener(this.DRAGDROP_EVENT,this.dragDropBound)}</span>,update:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.acceptableEntities=this.data.accepts.length?Array.prototype.slice.call(this.el.sceneEl.querySelectorAll(this.data.accepts)):null,this.data.autoUpdate&amp;&amp;null!=this.acceptableEntities?this.observer.observe(this.el.sceneEl,this.observerOpts):this.observer.disconnect()}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.HOVER_EVENT,this.hoverStartBound),this.el.removeEventListener(this.UNHOVER_EVENT,this.hoverEndBound),this.el.removeEventListener(this.DRAGDROP_EVENT,this.dragDropBound),this.observer.disconnect()}</span>,mutateAccepts:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.data.accepts;<span class="cstat-no" title="statement not covered" ></span>a.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >a.addedNodes.forEach(<span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >elementMatches(a,b)&amp;&amp;this.acceptableEntities.push(a)}</span>)}</span>)}</span>,entityAcceptable:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.acceptableEntities;<span class="cstat-no" title="statement not covered" ></span>if(null==b)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >f</span></span>or(const c of b)<span class="cstat-no" title="statement not covered" >if(c===a)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,hoverStart:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a.defaultPrevented||!this.entityAcceptable(a.detail.carried)||(this.el.addState(this.HOVERED_STATE),a.preventDefault&amp;&amp;a.preventDefault())}</span>,hoverEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a.defaultPrevented||this.el.removeState(this.HOVERED_STATE)}</span>,dragDrop:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >if(!a.defaultPrevented){const b=<span class="cstat-no" title="statement not covered" >a.detail.dropped;<span class="cstat-no" title="statement not covered" ></span>return this.entityAcceptable(b)?void(this.data.acceptEvent.length&amp;&amp;this.el.emit(this.data.acceptEvent,{el:b}),a.preventDefault&amp;&amp;a.preventDefault()):void(this.data.rejectEvent.length&amp;&amp;this.el.emit(this.data.rejectEvent,{el:b}))}</span>}</span>});
&nbsp;
},{}],6:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME, THREE */const inherit=<span class="cstat-no" title="statement not covered" >AFRAME.utils.extendDeep,</span>physicsCore=<span class="cstat-no" title="statement not covered" >require("./prototypes/physics-grab-proto.js"),</span>buttonsCore=<span class="cstat-no" title="statement not covered" >require("./prototypes/buttons-proto.js"),</span>base=<span class="cstat-no" title="statement not covered" >inherit({},physicsCore,buttonsCore);<span class="cstat-no" title="statement not covered" ></span>AFRAME.registerComponent("grabbable",inherit(base,{schema:{maxGrabbers:{type:"int",default:NaN},invert:{default:!1},suppressY:{default:!1}},init:<span class="fstat-no" title="function not covered" >fu</span>nction(){// persistent object speeds up repeat setAttribute calls</span>
<span class="cstat-no" title="statement not covered" >this.GRABBED_STATE="grabbed",this.GRAB_EVENT="grab-start",this.UNGRAB_EVENT="grab-end",this.grabbed=!1,this.grabbers=[],this.constraints=new Map,this.deltaPositionIsValid=!1,this.grabDistance=void 0,this.grabDirection={x:0,y:0,z:-1},this.grabOffset={x:0,y:0,z:0},this.destPosition={x:0,y:0,z:0},this.deltaPosition=new THREE.Vector3,this.targetPosition=new THREE.Vector3,this.physicsInit(),this.el.addEventListener(this.GRAB_EVENT,<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >this.start(a))</span>,this.el.addEventListener(this.UNGRAB_EVENT,<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >this.end(a))</span>,this.el.addEventListener("mouseout",<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >this.lostGrabber(a))</span>}</span>,update:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.physicsUpdate(),this.xFactor=this.data.invert?-1:1,this.zFactor=this.data.invert?-1:1,this.yFactor=(this.data.invert?-1:1)*!this.data.suppressY}</span>,tick:<span class="fstat-no" title="function not covered" >fu</span>nction(){const a=<span class="cstat-no" title="statement not covered" >new THREE.Quaternion,</span>b=<span class="cstat-no" title="statement not covered" >new THREE.Vector3;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){let c;<span class="cstat-no" title="statement not covered" >this.grabber&amp;&amp;(this.targetPosition.copy(this.grabDirection),this.targetPosition.applyQuaternion(this.grabber.object3D.getWorldQuaternion(a)).setLength(this.grabDistance).add(this.grabber.object3D.getWorldPosition(b)).add(this.grabOffset),this.deltaPositionIsValid?(this.deltaPosition.sub(this.targetPosition),c=this.el.getAttribute("position"),this.destPosition.x=c.x-this.deltaPosition.x*this.xFactor,this.destPosition.y=c.y-this.deltaPosition.y*this.yFactor,this.destPosition.z=c.z-this.deltaPosition.z*this.zFactor,this.el.setAttribute("position",this.destPosition)):this.deltaPositionIsValid=!0,this.deltaPosition.copy(this.targetPosition))}</span>}</span>(),remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.GRAB_EVENT,this.start),this.el.removeEventListener(this.UNGRAB_EVENT,this.end),this.physicsRemove()}</span>,start:<span class="fstat-no" title="function not covered" >fu</span>nction(a){var b=<span class="cstat-no" title="statement not covered" >Number.isFinite;<span class="cstat-no" title="statement not covered" ></span>if(!a.defaultPrevented&amp;&amp;this.startButtonOk(a)){// room for more grabbers?</span>
const c=<span class="cstat-no" title="statement not covered" >!b(this.data.maxGrabbers)||this.grabbers.length&lt;this.data.maxGrabbers;<span class="cstat-no" title="statement not covered" ></span>if(-1===this.grabbers.indexOf(a.detail.hand)&amp;&amp;c){<span class="cstat-no" title="statement not covered" >if(!a.detail.hand.object3D)<span class="cstat-no" title="statement not covered" >return void console.warn("grabbable entities must have an object3D");<span class="cstat-no" title="statement not covered" >t</span></span>his.grabbers.push(a.detail.hand),this.physicsStart(a)||this.grabber||(this.grabber=a.detail.hand,this.resetGrabber()),a.preventDefault&amp;&amp;a.preventDefault(),this.grabbed=!0,this.el.addState(this.GRABBED_STATE)}</span>}</span>},end:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.grabbers.indexOf(a.detail.hand);<span class="cstat-no" title="statement not covered" ></span>a.defaultPrevented||!this.endButtonOk(a)||(-1!==b&amp;&amp;(this.grabbers.splice(b,1),this.grabber=this.grabbers[0]),this.physicsEnd(a),!this.resetGrabber()&amp;&amp;(this.grabbed=!1,this.el.removeState(this.GRABBED_STATE)),a.preventDefault&amp;&amp;a.preventDefault())}</span>,resetGrabber:<span class="fstat-no" title="function not covered" >fu</span>nction(){const a=<span class="cstat-no" title="statement not covered" >new THREE.Vector3,</span>b=<span class="cstat-no" title="statement not covered" >new THREE.Vector3;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.grabber)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >this.grabber.getAttribute("raycaster");<span class="cstat-no" title="statement not covered" ></span>return this.deltaPositionIsValid=!1,this.grabDistance=this.el.object3D.getWorldPosition(a).distanceTo(this.grabber.object3D.getWorldPosition(b)),c&amp;&amp;(this.grabDirection=c.direction,this.grabOffset=c.origin),!0}</span>}</span>(),lostGrabber:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.grabbers.indexOf(a.relatedTarget);</span>// if a queued, non-physics grabber leaves the collision zone, forget it
<span class="cstat-no" title="statement not covered" >-1===b||a.relatedTarget===this.grabber||this.physicsIsConstrained(a.relatedTarget)||this.grabbers.splice(b,1)}</span>}));
&nbsp;
},{"./prototypes/buttons-proto.js":8,"./prototypes/physics-grab-proto.js":9}],7:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME */<span class="cstat-no" title="statement not covered" >AFRAME.registerComponent("hoverable",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.HOVERED_STATE="hovered",this.HOVER_EVENT="hover-start",this.UNHOVER_EVENT="hover-end",this.hoverers=[],this.start=this.start.bind(this),this.end=this.end.bind(this),this.el.addEventListener(this.HOVER_EVENT,this.start),this.el.addEventListener(this.UNHOVER_EVENT,this.end)}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.HOVER_EVENT,this.start),this.el.removeEventListener(this.UNHOVER_EVENT,this.end)}</span>,start:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >a.defaultPrevented||(this.el.addState(this.HOVERED_STATE),-1===this.hoverers.indexOf(a.detail.hand)&amp;&amp;this.hoverers.push(a.detail.hand),a.preventDefault&amp;&amp;a.preventDefault())}</span>,end:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >if(!a.defaultPrevented){const b=<span class="cstat-no" title="statement not covered" >this.hoverers.indexOf(a.detail.hand);<span class="cstat-no" title="statement not covered" ></span>-1!==b&amp;&amp;this.hoverers.splice(b,1),1&gt;this.hoverers.length&amp;&amp;this.el.removeState(this.HOVERED_STATE)}</span>}</span>});</span>
&nbsp;
},{}],8:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";// common code used in customizing reaction components by button
<span class="cstat-no" title="statement not covered" >module.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >a(</span>a,b){<span class="cstat-no" title="statement not covered" >return 0===b.length||-1!==b.indexOf(a.detail.buttonEvent.type)}<span class="cstat-no" title="statement not covered" ></span>return{schema:{startButtons:{default:[]},endButtons:{default:[]}},startButtonOk:<span class="fstat-no" title="function not covered" >fu</span>nction(b){<span class="cstat-no" title="statement not covered" >return a(b,this.data.startButtons)}</span>,endButtonOk:<span class="fstat-no" title="function not covered" >fu</span>nction(b){<span class="cstat-no" title="statement not covered" >return a(b,this.data.endButtons)}</span>}}</span>();</span>
&nbsp;
},{}],9:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";// base code used by grabbable for physics interactions
<span class="cstat-no" title="statement not covered" >module.exports={schema:{usePhysics:{default:"ifavailable"}},physicsInit:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constraints=new Map}</span>,physicsUpdate:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"never"===this.data.usePhysics&amp;&amp;this.constraints.size&amp;&amp;this.physicsClear()}</span>,physicsRemove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.physicsClear()}</span>,physicsStart:<span class="fstat-no" title="function not covered" >fu</span>nction(a){// initiate physics constraint if available and not already existing</span>
<span class="cstat-no" title="statement not covered" >if("never"!==this.data.usePhysics&amp;&amp;this.el.body&amp;&amp;a.detail.hand.body&amp;&amp;!this.constraints.has(a.detail.hand)){const b=<span class="cstat-no" title="statement not covered" >Math.random().toString(36).substr(2,9);<span class="cstat-no" title="statement not covered" ></span>return this.el.setAttribute("constraint__"+b,{target:a.detail.hand}),this.constraints.set(a.detail.hand,b),!0}</span>/</span>/ Prevent manual grab by returning true
<span class="cstat-no" title="statement not covered" >return"only"===this.data.usePhysics}</span>,physicsEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.constraints.get(a.detail.hand);<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;(this.el.removeAttribute("constraint__"+b),this.constraints.delete(a.detail.hand))}</span>,physicsClear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.el.body)<span class="cstat-no" title="statement not covered" >for(const a of this.constraints.values())<span class="cstat-no" title="statement not covered" >this.el.body.world.removeConstraint(a);<span class="cstat-no" title="statement not covered" >t</span></span></span>his.constraints.clear()}</span>,physicsIsConstrained:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >return this.constraints.has(a)}</span>,<span class="fstat-no" title="function not covered" >ph</span>ysicsIsGrabbing(){<span class="cstat-no" title="statement not covered" >return 0&lt;this.constraints.size}</span>};
&nbsp;
},{}],10:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME, THREE */const inherit=<span class="cstat-no" title="statement not covered" >AFRAME.utils.extendDeep,</span>buttonsCore=<span class="cstat-no" title="statement not covered" >require("./prototypes/buttons-proto.js"),</span>base=<span class="cstat-no" title="statement not covered" >inherit({},buttonsCore);<span class="cstat-no" title="statement not covered" ></span>AFRAME.registerComponent("stretchable",inherit(base,{schema:{usePhysics:{default:"ifavailable"},invert:{default:!1},physicsUpdateRate:{default:100}},init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.STRETCHED_STATE="stretched",this.STRETCH_EVENT="stretch-start",this.UNSTRETCH_EVENT="stretch-end",this.stretched=!1,this.stretchers=[],this.scale=new THREE.Vector3,this.handPos=new THREE.Vector3,this.otherHandPos=new THREE.Vector3,this.start=this.start.bind(this),this.end=this.end.bind(this),this.el.addEventListener(this.STRETCH_EVENT,this.start),this.el.addEventListener(this.UNSTRETCH_EVENT,this.end)}</span>,update:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.updateBodies=AFRAME.utils.throttleTick(this._updateBodies,this.data.physicsUpdateRate,this)}</span>,tick:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >if(!this.stretched)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.scale.copy(this.el.getAttribute("scale")),this.stretchers[0].object3D.getWorldPosition(this.handPos),this.stretchers[1].object3D.getWorldPosition(this.otherHandPos);c</span>onst c=<span class="cstat-no" title="statement not covered" >this.handPos.distanceTo(this.otherHandPos);</span>let d=<span class="cstat-no" title="statement not covered" >1;</span>// scale update for all nested physics bodies (throttled)</span>
<span class="cstat-no" title="statement not covered" >null!==this.previousStretch&amp;&amp;0!==c&amp;&amp;(d=Math.pow(c/this.previousStretch,this.data.invert?-1:1)),this.previousStretch=c,null==this.previousPhysicsStretch&amp;&amp;(this.previousPhysicsStretch=c),this.scale.multiplyScalar(d),this.el.setAttribute("scale",this.scale),this.updateBodies(a,b)}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.el.removeEventListener(this.STRETCH_EVENT,this.start),this.el.removeEventListener(this.UNSTRETCH_EVENT,this.end)}</span>,start:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >this.stretched||this.stretchers.includes(a.detail.hand)||!this.startButtonOk(a)||a.defaultPrevented||(// already stretched or already captured this hand or wrong button</span>
this.stretchers.push(a.detail.hand),2===this.stretchers.length&amp;&amp;(this.stretched=!0,this.previousStretch=null,this.previousPhysicsStretch=null,this.el.addState(this.STRETCHED_STATE)),a.preventDefault&amp;&amp;a.preventDefault())},end:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.stretchers.indexOf(a.detail.hand);<span class="cstat-no" title="statement not covered" ></span>a.defaultPrevented||!this.endButtonOk(a)||(-1!==b&amp;&amp;(this.stretchers.splice(b,1),this.stretched=!1,this.el.removeState(this.STRETCHED_STATE),this._updateBodies()),a.preventDefault&amp;&amp;a.preventDefault())}</span>,_updateBodies:<span class="fstat-no" title="function not covered" >fu</span>nction(){var a=<span class="cstat-no" title="statement not covered" >Math.pow;<span class="cstat-no" title="statement not covered" ></span>if(!this.el.body||"never"===this.data.usePhysics)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst b=<span class="cstat-no" title="statement not covered" >this.previousStretch;</span>// last visible geometry stretch
let d=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(null!==this.previousPhysicsStretch&amp;&amp;0&lt;b&amp;&amp;(d=a(b/this.previousPhysicsStretch,this.data.invert?-1:1)),this.previousPhysicsStretch=b,1!==d){<span class="cstat-no" title="statement not covered" >for(const a of this.el.childNodes)<span class="cstat-no" title="statement not covered" >this.stretchBody(a,d);<span class="cstat-no" title="statement not covered" >t</span></span>his.stretchBody(this.el,d)}</span>}</span>,stretchBody:<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >if(!a.body)<span class="cstat-no" title="statement not covered" >return;l</span></span>et c,d;<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;a.body.shapes.length;e++)// also move offset to match scale change</span>
<span class="cstat-no" title="statement not covered" >c=a.body.shapes[e],c.halfExtents?(c.halfExtents.scale(b,c.halfExtents),c.updateConvexPolyhedronRepresentation()):c.radius?(c.radius*=b,c.updateBoundingSphereRadius()):!this.shapeWarned&amp;&amp;(console.warn("Unable to stretch physics body: unsupported shape"),this.shapeWarned=!0),d=a.body.shapeOffsets[e],d.scale(b,d);<span class="cstat-no" title="statement not covered" >a</span>.body.updateBoundingRadius()}</span>}));
&nbsp;
},{"./prototypes/buttons-proto.js":8}],11:[<span class="fstat-no" title="function not covered" >fu</span>nction(require,module,exports){
"use strict";/* global AFRAME */<span class="cstat-no" title="statement not covered" >AFRAME.registerSystem("super-hands",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.superHands=[]}</span>,registerMe:<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >1===this.superHands.length&amp;&amp;(this.superHands[0].otherSuperHand=a,a.otherSuperHand=this.superHands[0]),this.superHands.push(a)}</span>,unregisterMe:<span class="fstat-no" title="function not covered" >fu</span>nction(a){const b=<span class="cstat-no" title="statement not covered" >this.superHands.indexOf(a);<span class="cstat-no" title="statement not covered" ></span>-1!==b&amp;&amp;this.superHands.splice(b,1),this.superHands.forEach(<span class="fstat-no" title="function not covered" >b=</span>&gt;{<span class="cstat-no" title="statement not covered" >b.otherSuperHand===a&amp;&amp;(b.otherSuperHand=null)}</span>)}</span>});</span>
&nbsp;
},{}]},{},[1]);
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at Sat May 28 2022 11:55:34 GMT+0700 (Indochina Time)
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    